Attribute VB_Name = "Module1"
Option Explicit
'This program was made on Windows 98, so if it doesn't work on NT, 2000, or XP, the four
'API calls below are what need changed.  I'm not on XP, so I don't know if there different

'Also the Function AOLChat and GetText would probably need fixed.
'That is all that needs changed...

Public Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Public Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Public Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Public Declare Function SendMessageByString Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As String) As Long

Public Const WM_GETTEXT = &HD
Public Const WM_GETTEXTLENGTH = &HE

Global buffer As String
Global chatWindow As Long
Global OK As Boolean
Global lineCount As Integer

'Generated by my CodeGen, variables names and all ;-)
Public Function AOLChat() As Long
   Dim AOL As Long, MDI As Long, AOLChild As Long
   Dim AOLStatic As Long, ChatText As Long, AOLList As Long
   AOL& = FindWindow("AOL Frame25", vbNullString)
   MDI& = FindWindowEx(AOL&, 0&, "MDIClient", vbNullString)
   AOLChild& = 0&
   Do
      DoEvents
      AOLChild& = FindWindowEx(MDI&, AOLChild&, "AOL Child", vbNullString) 'Get next window with the same class name
      AOLStatic& = FindWindowEx(AOLChild&, 0&, "_AOL_Static", vbNullString)
      ChatText& = FindWindowEx(AOLChild&, 0&, "RICHCNTLREADONLY", vbNullString)
      AOLList& = FindWindowEx(AOLChild&, 0&, "_AOL_Listbox", vbNullString)
      If AOLStatic& <> 0 And ChatText& <> 0 And AOLList& <> 0 Then 'Check if this is our child window
          AOLChat& = AOLChild&
          Exit Function
      End If
    Loop Until AOLChild& = 0&
   AOLChat& = 0&
End Function

Public Function GetText(WindowHandle As Long) As String
    Dim buffer As String, TextLength As Long
    TextLength& = SendMessage(WindowHandle&, WM_GETTEXTLENGTH, 0&, 0&)
    buffer$ = String(TextLength& + 1, 0&)
    Call SendMessageByString(WindowHandle&, WM_GETTEXT, TextLength& + 1, buffer$)
    GetText$ = buffer$
End Function

Public Function FixString(strLocal As String) As String
   Dim strTemp As String
   Dim i As Integer
   Dim lngStart As Long
   For i = Len(strLocal$) To Len(strLocal$) - 50 Step -1
      If Not Asc(Mid(strLocal$, i, 1)) = 0 Then
        strLocal$ = Mid(strLocal$, 1, Len(strLocal$) - (Len(strLocal$) - i))
        Exit For
      End If
   Next i

   'Check for Link -1 of X
   strTemp = Mid(strLocal$, Len(strLocal$) - 15, 15)
   lngStart& = InStr(strTemp, "Link -1")
   If lngStart& Then
      strLocal$ = Mid(strLocal$, 1, Len(strLocal$) - (18 - lngStart&))
   End If
   
   FixString = strLocal$
End Function

'Grabs the new text from the line read
'Finds the difference between the buffer text and what
'was read in and returns it.
Public Function FilterString(strs As String) As String
   Dim i As Integer, j As Integer
   Dim IM As Integer, jM As Integer
   Dim lngFind As Long
   
   IM = Len(buffer$)
   
   If Len(strs) > 1500 Then                          'I'm assuming that no chatroom will ever get more
      strs = Mid(strs, Len(strs) / 2, Len(strs))  'than 750 chars of new text with in the time of one read
   End If
   
   i = 1
   j = 1
   
   Do While i < IM
      DoEvents
      If Mid(buffer$, i, 1) = Mid(strs, j, 1) Then
         i = i + 1
         j = j + 1
      Else
         i = i - j + 2
         j = 1
      End If
   Loop
   
   strs = Mid(strs$, j + 2, Len(strs$))
   
   lngFind = InStr(strs, Chr$(13))                   'Error check
   If InStr(strs$, Chr$(9)) > lngFind& Then       'Sometimes a partial line will be at the top of the
      strs = Mid(strs, lngFind& + 1, Len(strs$))  'new text.  This will delete it
   End If
   
   FilterString = strs
End Function

